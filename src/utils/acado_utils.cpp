/*
 *    This file is part of ACADO Toolkit.
 *
 *    ACADO Toolkit -- A Toolkit for Automatic Control and Dynamic Optimization.
 *    Copyright (C) 2008-2011 by Boris Houska and Hans Joachim Ferreau, K.U.Leuven.
 *    Developed within the Optimization in Engineering Center (OPTEC) under
 *    supervision of Moritz Diehl. All rights reserved.
 *
 *    ACADO Toolkit is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    ACADO Toolkit is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with ACADO Toolkit; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */


/**
 *    \file src/utils/acado_utils.cpp
 *    \author Hans Joachim Ferreau, Boris Houska
 *    \date 31.05.2008
 */


#if defined(__WIN32__) || defined(WIN32)
  #include <windows.h>
#elif defined(LINUX)
  #include <sys/stat.h>
  #include <sys/time.h>
#endif


#include <acado/utils/acado_utils.hpp>



BEGIN_NAMESPACE_ACADO



/*
 *	p r i n t C o p y r i g h t N o t i c e
 */
returnValue acadoPrintCopyrightNotice(	const char* subpackage
										)
{
	if ( subpackage == 0 )
		return ((returnValue) acadoPrintf( "\nACADO Toolkit -- A Toolkit for Automatic Control and Dynamic Optimization.\nCopyright (C) 2008-2011 by Boris Houska and Hans Joachim Ferreau, K.U.Leuven.\nDeveloped within the Optimization in Engineering Center (OPTEC) under\nsupervision of Moritz Diehl. All rights reserved.\n\nACADO Toolkit is distributed under the terms of the GNU Lesser\nGeneral Public License 3 in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Lesser General Public License for more details.\n\n" ) );
	else
		return ((returnValue) acadoPrintf( "\nACADO Toolkit::%s\nCopyright (C) 2008-2011 by Boris Houska and Hans Joachim Ferreau, K.U.Leuven.\nDeveloped within the Optimization in Engineering Center (OPTEC) under\nsupervision of Moritz Diehl. All rights reserved.\n\nACADO Toolkit is distributed under the terms of the GNU Lesser\nGeneral Public License 3 in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Lesser General Public License for more details.\n\n",subpackage ));
}


returnValue acadoPrintAutoGenerationNotice(	FILE* file,
											const char* commentString
											)
{
	if ( commentString == 0 )
	{
		acadoFPrintf( file,"/*\n" );
		acadoFPrintf( file," *    This file was auto-generated by ACADO Toolkit.\n" );
		acadoFPrintf( file," *\n");
		acadoFPrintf( file," *    ACADO Toolkit -- A Toolkit for Automatic Control and Dynamic Optimization.\n" );
		acadoFPrintf( file," *    Copyright (C) 2008-2011 by Boris Houska, Hans Joachim Ferreau et al., K.U.Leuven.\n" );
		acadoFPrintf( file," *    Developed within the Optimization in Engineering Center (OPTEC) under\n" );
		acadoFPrintf( file," *    supervision of Moritz Diehl. All rights reserved.\n" );
		acadoFPrintf( file," *\n" );
		acadoFPrintf( file," */\n" );
	}
	else
	{
		acadoFPrintf( file,"%s\n",commentString );
		acadoFPrintf( file,"%s    This file was auto-generated by ACADO Toolkit.\n",commentString );
		acadoFPrintf( file,"%s\n",commentString );
		acadoFPrintf( file,"%s    ACADO Toolkit -- A Toolkit for Automatic Control and Dynamic Optimization.\n",commentString );
		acadoFPrintf( file,"%s    Copyright (C) 2008-2011 by Boris Houska, Hans Joachim Ferreau et al., K.U.Leuven.\n",commentString );
		acadoFPrintf( file,"%s    Developed within the Optimization in Engineering Center (OPTEC) under\n",commentString );
		acadoFPrintf( file,"%s    supervision of Moritz Diehl. All rights reserved.\n",commentString );
		acadoFPrintf( file,"%s\n",commentString );
	}

	acadoFPrintf(file,"\n");
	acadoFPrintf(file,"\n");

    return SUCCESSFUL_RETURN;
}



/*
 *	g e t C P U t i m e
 */
double acadoGetTime( )
{
	double current_time = 0.0;

	#if defined(__WIN32__) || defined(WIN32)
	LARGE_INTEGER counter, frequency;
	QueryPerformanceFrequency(&frequency);
	QueryPerformanceCounter(&counter);
	current_time = ((double) counter.QuadPart) / ((double) frequency.QuadPart);
	#elif defined(LINUX)
	struct timeval theclock;
	gettimeofday( &theclock,0 );
	current_time = 1.0*theclock.tv_sec + 1.0e-6*theclock.tv_usec;
	#endif

	return current_time;
}


BooleanType acadoIsInteger( double x )
{
	//if ( fabs( x - floor( x + 0.5) ) < 10000.0*EPS )
	if ( fabs( x - floor( x + 0.5) ) < 1.0e-5 )
		return BT_TRUE;
	else
		return BT_FALSE;
}


double acadoDiv( double nom, double den )
{
	if ( acadoIsInteger( nom/den ) == BT_TRUE )
		return floor( nom/den + 0.5 );
	else
		return floor( nom/den );
}


double acadoMod( double nom, double den )
{
	if ( acadoIsInteger( nom/den ) == BT_TRUE )
		return 0.0;
	else
		return ( nom/den ) - floor( nom/den );
}


int acadoMax( const int x, const int y ){

    return (y<x)?x:y;
}


double acadoMax( const double x, const double y ){

    return (y<x)?x:y;
}


int acadoMin( const int x, const int y ){

    return (y>x)?x:y;
}


double acadoMin( const double x, const double y ){

    return (y>x)?x:y;
}


BooleanType acadoIsEqual( const char* str1, const char* str2 )
{
	if ( ( str1 == 0 ) && ( str2 == 0 ) )
		return BT_TRUE;

	if ( ( str1 == 0 ) && ( str2 != 0 ) )
		return BT_FALSE;

	if ( ( str1 != 0 ) && ( str2 == 0 ) )
		return BT_FALSE;

	if ( strcmp( str1,str2 ) == 0 )
		return BT_TRUE;
	else
		return BT_FALSE;
}


BooleanType acadoIsEqual( double x, double y, double TOL ){

	if( acadoMax(x,y) > 1)
	{
		// use relative error
		if ( fabs( x-y )/acadoMax(x,y) >= 10.0*TOL ) return BT_FALSE;
		else                      return BT_TRUE ;
	}
	else
	{
		// use absolute error
		if ( fabs( x-y ) >= 10.0*TOL ) return BT_FALSE;
		else                      return BT_TRUE ;
	}
}


BooleanType acadoIsGreater( double x, double y, double TOL ){

    if ( x >= y - TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsSmaller( double x, double y, double TOL ){

    if ( x <= y + TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsStrictlyGreater( double x, double y, double TOL ){

    if ( x > y + TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsStrictlySmaller( double x, double y, double TOL ){

    if ( x < y - TOL ) return BT_TRUE ;
    else                return BT_FALSE;
}


BooleanType acadoIsPositive( double x, double TOL ){

    if ( x >= TOL ) return BT_TRUE ;
    else            return BT_FALSE;
}


BooleanType acadoIsNegative( double x, double TOL ){

    if ( x <= -TOL ) return BT_TRUE ;
    else             return BT_FALSE;
}


BooleanType acadoIsZero( double x, double TOL ){

    return acadoIsEqual( x, 0.0, TOL );
}


BooleanType acadoIsInfty( double x, double TOL )
{
	if ( ( acadoIsGreater( x, INFTY, TOL ) == BT_TRUE ) ||
		 ( acadoIsSmaller( x,-INFTY, TOL ) == BT_TRUE ) )
		return BT_TRUE;
	else
		return BT_FALSE;
}


BooleanType acadoIsFinite( double x, double TOL )
{
	if ( ( acadoIsStrictlySmaller( x, INFTY, TOL ) == BT_TRUE ) &&
		 ( acadoIsStrictlyGreater( x,-INFTY, TOL ) == BT_TRUE ) )
		return BT_TRUE;
	else
		return BT_FALSE;
}


BooleanType acadoIsNaN(	double x
						)
{
	if ( ( x > -1.0 ) || ( x < 1.0 ) )
		return BT_FALSE;
	else
		return BT_TRUE;
}



int acadoRound (double x){

	if (x - floor(x) > 0.5)
		return (int)ceil(x);
	else
		return (int)floor(x);

}


returnValue acadoAssignString(	char** toString,
								const char* const fromString,
								const char* const defaultString
								)
{
	if ( *toString == 0 )
		*toString = new char[MAX_LENGTH_NAME+1];

	if ( fromString != 0 )
	{
		for( uint i=0; i<=MAX_LENGTH_NAME; ++i )
		{
			(*toString)[i] = fromString[i];

			if ( fromString[i] == '\0' )
				break;
		}
	}
	else
	{
		/* if fromString is empty, use defaultString */
		if ( defaultString != 0 )
		{
			for( uint i=0; i<=MAX_LENGTH_NAME; ++i )
			{
				(*toString)[i] = defaultString[i];

				if ( defaultString[i] == '\0' )
					break;
			}
		}
		else
			return ACADOERROR( RET_UNKNOWN_BUG );
	}

	return SUCCESSFUL_RETURN;
}


CLOSE_NAMESPACE_ACADO


/*
 *	end of file
 */
